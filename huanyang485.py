#!/bin/python
import serial
import crc16

'''

Set the VFD paramaters as:

    PD001: 2 (Source of run commands: communication port)
    PD002: 2 (Source of operating frequency: communication port)
    PD163: 1 (Communication address: 1)
    PD164: 1 (Communication Baud Rate: 9600)
    PD165: 3 (Communication Data Method: 8N1 RTU)

Possible data bits
    0 = run
    1 = for
    2 = rev
    3 = stop
    4 = r/f
    5 = jog
    6 = jogf
    7 = jogr


'''
examples = '''
h.send(function=3, data=0x01) # start
h.send(function=3, data=0x02) # for
h.send(function=3, data=0x10) # reverse/forward
h.send(function=5, data=0x600, parameter=0x00) # set frequency in hz*100
h.send(function=3, data=0x08) # stop spindle
'''

# bits in Status Data
STATUS_SetF = 0x00 # Set frequency command
STATUS_OutF = 0x01 # Actual output frequency
STATUS_OutA = 0x02 # Actual output Amps
STATUS_RoTT = 0x03 # Actual spindle speed in rpm
STATUS_DCV = 0x04 # DC Volts (to be confirmed)
STATUS_ACV = 0x05 # AC Volts (to be confirmed)
STATUS_Cont = 0x06
STATUS_Tmp = 0x07 # Temperature (to be confirmed)

# control commands CNTR
CONTROL_Run_Fwd = 0x01
CONTROL_Run_Rev =	0x11
CONTROL_Stop = 0x08

# control responses CNST
CONTROL_Run	= 0x01
CONTROL_Jog	 = 0x02
CONTROL_Command_rf = 0x04
CONTROL_Running	= 0x08
CONTROL_Jogging	= 0x10
CONTROL_Running_rf = 0x20
CONTROL_Bracking = 0x40
CONTROL_Track_Start = 0x80

class Huanyang_rs485(object):
  
  def __init__(self, device='/dev/ttyUSB0', baudrate=9600, address=1, debug=False):
    self.device = device
    self.baudrate = baudrate
    self.address = 1
    self.serial = serial.Serial(self.device, baudrate=self.baudrate)
    self.debug = debug
    self.modbus_ok = False

  def Send(self, function=1, data=None, parameter=None):
    """Send a message to the VFD, adds crc"""
    if function < 3: #function_read, function_write
      length = 3
      crc = crc16((self.address, function, length, parameter, data >> 8, data & 0x00F))
      outbytes = chr(self.address) + chr(function) + chr(length) + chr(parameter) + chr(data >> 8) + chr(data & 0x00ff) + chr(crc[0]) + chr(crc[1])      
      returnlength = 8
      
    elif function < 5: #write_control_data, read_control_status
      length = 1
      crc = crc16((self.address, function, length, data & 0x00FF))
      outbytes = chr(self.address) + chr(function) + chr(length) + chr(data & 0x00FF) + chr(crc[0]) + chr(crc[1])
      if function == 4:
        returnlength = 8
      else:
        returnlength = 6

    elif function == 5: # WRITE_FREQ_DATA
      length = 2
      crc = crc16((self.address, function, length, data >> 8, data & 0x00FF))
      outbytes = chr(self.address) + chr(function) + chr(length) + chr(data >> 8) + chr(data & 0x00FF) + chr(crc[0]) + chr(crc[1])
      returnlength = 7    

    else:
      returnlength = 0
    
    if self.debug:
      print crc
      print hex(crc[0]) + hex(crc[1])
      print outbytes
    
    self.serial.write(outbytes)
    return returnlength

  def Read(self, length):
    if length:
      self.modbus_ok = True
      return self.serial.read(length)
    self.modbus_ok = False
    return False

  def StartSpindel(self):
    return self.Read(self.Send(function=3, data=CONTROL_Run_Fwd)) # start
    
  def StopSpindel(self):
    return self.Read(self.Send(function=3, data=CONTROL_Stop)) # stop spindle

  def GetStatus(self, data):
    rott = self.Read(self.Send(function=4, data=data))
    return (ord(rott[4]) << 8  | ord(rott[5]))

  def GetFrequency(self):
    frequency = self.Read(self.Send(function=4, data=STATUS_OutF))
    return (ord(frequency[4]) << 8  | ord(frequency[5])) / 100
    
  def SetFrequency(self, frequency):
    frequency = min(int(self.max_frequency), frequency)
    frequency = self.Read(self.Send(function=5, data=frequency*100, parameter=0x00))
    return (ord(frequency[3]) << 8  | ord(frequency[4])) / 100

  def Reverse(self):
    return self.Read(self.Send(function=3, data=CONTROL_Run_Rev)) # reverse/forward

  def GetInfo(self, parameter, factor=1):
    data = self.Read(self.Send(function=1, data=0x0000, parameter=parameter))
    return (ord(data[4]) << 8  | ord(data[5])) * factor

  def Base_frequency(self):
    return self.GetInfo(4, 0.01)

  def Max_frequency(self):
    return self.GetInfo(5, 0.01)
    
  def Min_frequency(self):
    return self.GetInfo(11, 0.01)

  def Rated_motor_voltage(self):
    return self.GetInfo(141, 0.1)

  def Rated_motor_current(self):
    return self.GetInfo(142, 0.1)

  def Motor_poles(self):
    return self.GetInfo(143)

  def Rated_motor_rpm(self):
    return self.GetInfo(144)

  def ReadSetup(self):
     self.base_frequency = self.Base_frequency()
     self.max_frequency = self.Max_frequency()
     self.min_frequency = self.Min_frequency()     
     self.rated_motor_voltage = self.Rated_motor_voltage()
     self.rated_motor_current = self.Rated_motor_current()
     #self.motor_poles = self.Motor_poles()
     self.rated_motor_rpm = self.Rated_motor_rpm()

#Table of CRC values for high-order byte 
table_crc_hi = (
  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
  0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
  0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 
  0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 
  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 
  0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 
  0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 
  0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 
  0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
  0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
  0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
  0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 
  0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 
  0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
)

# Table of CRC values for low-order byte 
table_crc_lo = (
  0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 
  0x07, 0xC7, 0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 
  0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 
  0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 
  0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC, 0x14, 0xD4, 
  0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3, 
  0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 
  0xF2, 0x32, 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 
  0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 
  0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 
  0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 
  0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26, 
  0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 
  0x61, 0xA1, 0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 
  0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 
  0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 
  0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 
  0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5, 
  0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 
  0x70, 0xB0, 0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 
  0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 
  0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 
  0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 
  0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C, 
  0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 
  0x43, 0x83, 0x41, 0x81, 0x80, 0x40
)
  
def crc16(data):
  crc_hi = 0xFF # high CRC byte initialized
  crc_lo = 0xFF # low CRC byte initialized
  i = 0 # will index into CRC lookup

  # pass through message buffer */
  for byte in data:
    i = crc_hi ^ byte # calculate the CRC
    crc_hi = crc_lo ^ table_crc_hi[i]
    crc_lo = table_crc_lo[i]

  return (crc_hi, crc_lo)
